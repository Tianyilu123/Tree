
public class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildTree(inorder, inorder.length-1, 0, postorder, postorder.length-1);
    }

    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart) {
     if(postStart<0||inEnd > inStart)return null;
     TreeNode root = new TreeNode(postorder[postStart]);
     //find root pos in inorder,can also use hashmap to store pos
     int inIdx = 0;
     for(int i=inStart;i>=inEnd;i--){
         if(inorder[i]==postorder[postStart]){
             inIdx = i;
             break;
         }
     }
     root.left = buildTree(inorder, inIdx-1, inEnd, postorder, postStart-(inStart-inIdx+1));
        //reverse wrong, locate left subtree root
     root.right = buildTree(inorder,inStart, inIdx + 1, postorder, postStart-1);
        //2nd last is root of right subtree
     return root;
    }
}

// Time O(N) , 
// Space O(N)       
